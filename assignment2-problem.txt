1）What is the advantage of using a tail pointer in a linked list?
1. No need to traverse the entire linked list from the beginning; elements can be quickly inserted at the tail, reducing the tail insertion operation complexity to O(1). 
2. With head and tail pointers, both tail insertion and head deletion remain efficient, facilitating the implementation of data structures like queues.

2）
class ListNode:
    def __init__(self, val):
        self.val = val
        self.next = None

def doIt(node):
    if node is None:         
        return
    doIt(node.next)          
    print(node.val)          

head = ListNode(12)
n1 = ListNode(3)
n2 = ListNode(5)
n3 = ListNode(2)

head.next = n1
n1.next = n2
n2.next = n3

doIt(head)

result:
2
5
3
12

3)
def doIt(n):
    if n == 0:
        return 1
    elif n == 1:
        return 1
    elif n == 2:
        return 2
    else:
        return doIt(n-1) + doIt(n-2) - doIt(n-3)

print("doIt(1) =", doIt(1))
print("doIt(3) =", doIt(3))
print("doIt(6) =", doIt(6))
result:
doIt(1) = 1
doIt(3) = 2
doIt(6) = 4
Explain:
1.doIt(1)：according to base case→ 1
2.doIt(3) = doIt(2) + doIt(1) - doIt(0)= 2 + 1 - 1= 2
3.doIt(6) = doIt(5) + doIt(4) - doIt(3)
doIt(3) = doIt(2) + doIt(1) - doIt(0)= 2 + 1 - 1= 2
doIt(4) = doIt(3) + doIt(2) - doIt(1) = 2 + 2 - 1 = 3
doIt(5) = doIt(4) + doIt(3) - doIt(2) = 3 + 2 - 2 = 3
doIt(6) = doIt(5) + doIt(4) - doIt(3) = 3 + 3 - 2 = 4

4)
class ListNode:
    def __init__(self, x):
        self.val = x
        self.prev = None
        self.next = None
def getSum(head):
    slow = head
    fast = head
    while fast and fast.next:
        fast = fast.next.next
        slow = slow.next
    return slow.prev.val + slow.val + slow.next.val
nums = [2, 4, 8, 10, 15, 29, 41]
node_list = [ListNode(x) for x in nums]
for i in range(len(node_list)-1):
    node_list[i].next = node_list[i+1]
    node_list[i+1].prev = node_list[i]
head = node_list[0]
print("Sum of middle three =", getSum(head))

description：1. Program Objective
The objective of this program is to locate the middle three nodes in an odd-length ordered doubly linked list and calculate their sum.
2. Node Class Design
The `ListNode` class represents a node in the doubly linked list. Each node contains three components:
`val`: Stores the numerical value of the current node;
prev: Points to the previous node; None if none exists;
next: Points to the next node; None if none exists.
3. List Construction
Seven nodes are created with values 2, 4, 8, 10, 15, 29, 41.
By connecting them sequentially via the next and prev pointers, a doubly linked list is formed:
2 ↔ 4 ↔ 8 ↔ 10 ↔ 15 ↔ 29 ↔ 41
4. Function getSum
Approach: Use two pointers, slow and fast, to locate the middle node of the list.
slow moves one step at a time;
fast moves two steps at a time;
When `fast` reaches the end of the list, `slow` will be positioned at the middle node.
After locating the middle node, return the sum of its previous, current, and next node values.
5. Execution Flow
List: 2, 4, 8, 10, 15, 29, 41
Initial: `slow=2`, `fast=2`
First iteration: `slow=4`, `fast=8`
Second iteration: slow=8, fast=15
Third iteration: slow=10, fast=41 (fast reaches end, loop terminates)
At this point, slow points to the midpoint 10. Extract:
slow.prev = 8
slow = 10
slow.next = 15
Final calculation result:
8 + 10 + 15 = 33


